/*
This file is supplemental material to the paper
"Attempting the impossible: enumerating extremal submodular functions for n=6"
by E P Csirmaz and L Csirmaz.

Copyright 2024 E P Csirmaz and L Csirmaz

This program is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your option)
any later version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
more details.

You should have received a copy of the GNU General Public License along with
this program.  If not, see <https://www.gnu.org/licenses/>.
*/

/* This program produces extremal rays from the solution to the neigbor
   subproblem as described in Section IV-B of the paper. The program
   outputs the canonical representative of the orbit of the new ray
   rather than the ray itself.
   usage: newrays [--ray] <infile> <outfile> <baseray>
      --ray: save the ray, not the orbit
   infile: 
o first line: 
o   1 <axno>
o second line:
o   <axno> all axioms on which the baseray vanishes
o from third line:
o   DIM many coordinates of the next extremal ray

*/

#define T_FACTOR    static int
#if RANK==3
#  include "ax3.c"
#  include "sym3.c"
#elif RANK==4
#  include "ax4.c"
#  include "sym4.c"
#elif RANK==5
#  include "ax5.c"
#  include "sym5.c"
# elif RANK==6
#  include "ax6.c"
#  include "sym6.c"
# else
#  error RANK should be defined to 3,4,5,6
#endif

#define DIM    VARS

#define stringify(x)    #x
#define mkstringof(x)   stringify(x)


/* =================================================================== */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static void usage(void) {
    printf(
"usage: newr" mkstringof(RANK) " [--ray] <infile> <outfile> <baseray>\n"
"extracting extremal rays from the list of neighbor subproblem for rank=" mkstringof(RANK) "\n"
"  --ray    save the ray, not the orbit\n"
"  infile   result of the reduced problem generated by neig" mkstringof(RANK) "\n"
"  outfile  new rays are appended to this file\n"
"  baseray  comma separated list of coordinates of the base ray\n");
    exit(1);
}


static int baseray[DIM];   /* the base ray from the argument */
static int neigray[DIM];   /* the neightbor ray */
static double newray[DIM]; /* new ray is computed here */
static int intray[DIM];    /* the integer form of newray */
static int noorbit;        /* 1 if no minimal version */

static FILE *ifile;        /* input file */
static FILE *ofile;        /* output file */


static int is_digit(char c) {
    return '0' <= c && c <= '9';
}


static void handle_params(int argc, const char *argv[]) {
    const char *w; 
    int n;
    
    noorbit = 0;
    if(argc >= 2 && strcmp(argv[1], "--ray") == 0) {
        argc--; 
        argv++; 
        noorbit = 1;
    }
    if(argc != 4) usage();
    w = argv[3]; /* base ray */
    for(int i = 0; i < DIM; i++) {
        if(*w == ',') w++;
        if(!is_digit(*w)) { printf("wrong character %c in base ray coord %d\n", *w || '?', i); exit(1); }
        n = *w - '0'; 
        w++;
        while(is_digit(*w)) { 
            n = 10 * n + (*w - '0'); 
            w++;
            if(n > 10000) { printf("large coord %d at %d\n", n, i); exit(1); }
        }
        baseray[i] = n;
    }
    if(*w) { printf("Additional character %c at baseray\n", *w); exit(1); }
    if(!argv[1] || ! *(argv[1]) || (ifile = fopen(argv[1], "r")) == NULL) {
        printf("Cannot open the input file\n"); exit(1);
    }
    if(!argv[2] || ! *(argv[2]) || (ofile = fopen(argv[2], "a")) == NULL) {
        printf("Cannot append to the output file\n"); exit(1);
    }
}


/* ==========================================================================*/

static inline int is_zero(double x) {
     return (-1e-10 < (x) && (x) < 1e-10);
}


static inline int not_zero(double x) {
    return ((x) <= -1e-10 || (x) >= 1e-10);
}


static int iinner(int axno, int *ray) {
    int v = 0; 
    int *ax = axioms[axno];
    for(int i = 0; i < DIM; i++) v += ax[i] * ray[i];
    return v;
}


/* smallest multiple of v which is an integer */
static int lcm(double v) {
    for(int dd = 2; dd < 200; dd++) {
        if(is_zero(v * dd - (int)(v*dd + 1e-8))) return dd;
    }
    printf("lcm: strange value to make an integer: %lg\n", v); 
    exit(1);
    return 1;
}


/* gcd of two non-negative numbers, fast iterative Euclidean algorithm */
static int gcd(int x, int y) {
again:
    if(x == 1) { return 1; } 
    if(x == 0) { return y; }
    y %= x; 
    if(y == 0) { return x; } 
    if(y == 1) { return 1; }
    x %= y; 
    goto again;
}


/* make all coeffs of newray[] integer; store it in intray[].
   all coeffs in newray[] MUST be non-negative (not checked)
*/
static void integrify(void) { 
    int d, idx; 
    double v; 
    int iv;

    for(int i = 0; i < DIM; i++) intray[i] = 0;
    d = 1;
    for(int i = 0; i < DIM; i++) {
        v = d * newray[i]; 
        iv = (int)(v + 1e-8);
        intray[i] = iv;
        if(not_zero(v - iv)) {  d *= lcm(v - iv); }
    }
    if(d != 1) {
        for(int i = 0; i < DIM; i++) {
            v = d * newray[i]; 
            iv = (int)(v + 1e-8);
            intray[i] = iv;
            if(not_zero(v - iv)) { printf("integrify problem v=%f,iv=%d\n", v, iv); exit(1); }
        }
    }
    d = gcd(intray[0], intray[1]); 
    idx = 2;
    while(d != 1 && idx < DIM) { 
        d = gcd(intray[idx], d); 
        idx++; 
    }
    if(d > 1) { for(int i = 0; i < DIM; i++) intray[i] /= d; }
}


/* from baseray[] and neigray[] determine the double newray[]
   when found, call interify() to store the new ray in intray[]
*/

static int baseinner[AXIOMS]; /* baseinner[axn]=iiner(axn,baseray) */

static void find_neighbor(void) {
    int midx, iv1, iv2; 
    double mv, v;
    static int baseinnerfilled = 0; /* make sure it is filled only once */
    
    if(!baseinnerfilled) { 
        baseinnerfilled = 1;
        for(int axn = 0; axn < AXIOMS; axn++) baseinner[axn] = iinner(axn, baseray);
    }
    midx = -1;
    mv = 0;
    for(int axn = 0; axn < AXIOMS; axn++) {
        iv1 = baseinner[axn]; 
        iv2 = iinner(axn, neigray);
        if(iv1 == 0) { 
            if(iv2 < 0) { printf("Impossible, neigray negative\n"); exit(1); }
        } else {
            v = ((double)iv2) / ((double)iv1);
            if(midx < 0 || mv > v) { midx = axn; mv = v; }
        }
    }
    if(midx < 0) { printf("Impossible: cannot make neigray to inner\n"); exit(1); }
    for(int i = 0; i < DIM; i++) {
        newray[i] = ((double)(neigray[i])) - mv * ((double)(baseray[i]));
    }
    integrify(); /* now convert newray[] => intray[] */
}


/* ====================================================================== */

/* find the minimal permutation of intray[] */

static int minperm[DIM];     // the minimal permutation found so far 
static int dual[DIM];        // the dual of intray[]
static int nextperm[DIM];    // next permutation is generated here

static void fill_dual(void) { // fill dual[]
    for(int i = 0; i < DIM; i++) {
        dual[i] = 0;
        for(int j = 0; j < DIM; j++) { dual[i] += intray[j] * dualmatrix[i][j]; }
    }
}


static int cmp_as_string(int a1, int b1) {
    if(a1 == b1) return 0; 
    if(a1 < b1) return +1; 
    return -1; 
}


/* if nextperm[] is lexicographycally smaller than mimperm, replace */
static void lexminperm(void) {
    int smaller = 0;
    
    for(int i = 0; smaller == 0 && i < DIM; i++) {
        smaller = cmp_as_string(nextperm[i], minperm[i]);
    }
    if(smaller > 0) {
       for(int i = 0; i < DIM; i++) minperm[i] = nextperm[i];
    }
}


static void find_minperm(void) {
    // fill the minimal value
    for(int i = 0; i < DIM; i++) { minperm[i] = intray[i]; }
    if(noorbit) return;
    fill_dual(); // and compute the dual
    for(int pm = 0; pm < VPERMNO; pm++) {
        for(int i = 0; i < DIM; i++) nextperm[i] = intray[VPERMS[pm][i]];
        lexminperm();
        for(int i = 0; i < DIM; i++) nextperm[i] = dual[VPERMS[pm][i]];
        lexminperm();
    }
}


// how many axioms are satisfied by minperm[]
static int find_axrank(void) {
    int total = 0;
    
    for(int axn = 0; axn < AXIOMS; axn++) {
        if(iinner(axn, minperm) == 0) total++;
    }
    return total;
}


static void print_minperm(void) {
    fprintf(ofile, "%d: %d", find_axrank(), minperm[0]);
    for(int i = 1; i < DIM; i++) fprintf(ofile, ",%d", minperm[i]);
    fprintf(ofile, "\n");
}


/* =============================================================================== */
/* axioms handled; on these the base ray vanished */
static int handled_axioms[AXIOMS];

static void skip_input_header(void) {
    int n, w;
    
    for(int i = 0; i < AXIOMS; i++) { handled_axioms[i] = -1; }
    n = w = 0; 
    if(fscanf(ifile, "%d", &w) != 1 || w!=1 || 
        fscanf(ifile, "%d%d", &w, &n) != 2 || n < DIM-1 || n >= AXIOMS
    ) {
        printf("error in ray file header\n"); 
        exit(1);
    }
    
    for(; n > 0; n--) {
        if(fscanf(ifile, "%d", &w) != 1 || w < 0 || w >= AXIOMS || handled_axioms[w] > 0) {
            printf("error in ray file header list\n"); exit(1);
        }
        handled_axioms[w] = 1;
    }
    
    for(int i = 0; i < AXIOMS; i++) {
        if(handled_axioms[i] > 0) {
            if(iinner(i, baseray) != 0) { printf("ray file header: axiom %d should be zero\n", i); exit(1); }
        } else if(iinner(i, baseray) == 0) { 
            printf("ray file header: axiom %d should NOT be zero\n", i); exit(1); }
    }
}


static int read_next_ray(void) {
    int ret;
    
    ret = fscanf(ifile, "%d", &(neigray[0]));
    if(ret < 0) return 0; // no more ray
    if(ret != 1) { printf("Error reading next ray\n"); exit(1); }
    for(int i = 1; i < DIM; i++)
        if(fscanf(ifile, "%d", &(neigray[i])) != 1) {
            printf("Error reading coordinate %d of next ray\n", i); exit(1);
        }
    return 1;
}


/* ===================================================================== */

int main(int argc, const char *argv[]) {
    int total = 0;
    
    handle_params(argc, argv);
    skip_input_header();
    while(read_next_ray()) { // next neigray has been read
        find_neighbor();     // generate next ray to intray[]
        find_minperm();      // minimal symmetric version; can be the same as before
        print_minperm();
        total++;
    }
    fclose(ifile);
    fclose(ofile);
    printf("*** %d rays appended to file %s\n", total, argv[2]);
    return 0;
}


/* EOF */
